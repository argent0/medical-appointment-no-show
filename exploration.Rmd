```{r setup, results="hide", echo=FALSE}
require("dplyr", warn.conflicts=FALSE, quietly = TRUE)
#options(knitr.package.echo=FALSE)
#options(knitr.package.dev=c("svg"))
```

# Exploring No Show data

##Context

From the source:

> A person makes a doctor appointment, receives all the instructions and
> no-show. Who to blame? 

The objectives of this exploration are:
First, to visually present the composition of the sample data;
And second, to show how the appointments' features relate to whether the
patients will show up nor not.


```{r helper_functions}
const <- function (v = stop("v not supplied")) {
    tmp <- substitute(function() {
        return(v)
    })
    eval(tmp, parent.frame())
}
`%$%` <- function (f = stop("f not supplied"), v = stop("v not supplied")) {
    tmp <- substitute((f(v)))
    eval(tmp, parent.frame())
}
```

```{r load_data, cache=TRUE}
#Loading the data
appData <-
	read.csv(
		 unz("data/noshowappointments.zip", "KaggleV2-May-2016.csv"),
		 header=TRUE)
```

## Available Features.

The structure of the data is:

```{r structure}
str(appData)
```

Next are some variables that might require a short explanation:

* **ScheduledDay**: The day the appointment was scheduled.
* **AppointmentDay**: The day of the appointment.
* **Neighbourhood**: The Neighbourhood where the clinic is located.
* **Scholarship**: 1 if the person receives
  [aid from the government](https://en.wikipedia.org/wiki/Bolsa_Fam%C3%ADlia).
* **Handcap**: According to the source, A number that represents the person's
  disabilities.
* **SMS_received**: Whether the people received an SMS reminding them of the
  appointment. 
* **No.show**: The value "Yes", means that the person missed the appointment.
  The value "No", means that the person didn't miss the appointment.

## Computing Derived Features.

One of the factors that might be relevant to the turn up ratio is the
length of time from the day the appointment was scheduled to the appointment
itself. Let us, thus, define:

**Wait** as the number of days from the scheduling date to the appointment date.

```{r compute_wait, cache=TRUE}
schedDay <- const (
	sapply(X = (appData$ScheduledDay %>% as.character %>% strsplit("T")),
	       FUN=`[[`, 1) %>%
	strptime("%Y-%m-%d") %>% as.Date)


appDay <- const (
	sapply(X = (appData$AppointmentDay %>% as.character %>% strsplit("T")),
	       FUN=`[[`, 1) %>%
	strptime("%Y-%m-%d") %>% as.Date)

appData$Wait= (appDay() - schedDay()) %>% as.numeric #in days
appData$ScheduledDay = schedDay()
appData$AppointmentDay = appDay()
```

## Cleaning The Data

Some rows with negative `Wait` or `Age` where ignored when performing the
analysis.

```{r remove_negative_wait_and_age}
appData <- appData[appData$Wait>=0,]
appData <- appData[appData$Age>=0,]
```

## Some numbers about the data

```{r eda}
eda <- list()
eda$n_samples <- nrow(appData) #110,521
eda$n_patients <- length(unique(appData$PatientId)) #62,298
eda$n_appointments <- length(unique(appData$AppointmentID)) #one row per appointment
eda$n_neighbourhoods <- nlevels(appData$Neighbourhood) #81
eda$range_wait <- range( appData$Wait ) # Waits of up to 179 days
eda$range_scheduledDay <- range( appData$ScheduledDay ) #"2015-11-10" "2016-06-08"
eda$range_appointmentDay <- range( appData$AppointmentDay ) #"2016-04-29" "2016-06-08"
```

## Data composition

First a visualization of the sample's composition. Starting with the proportion
of missed appointments, which is the target of the study.

```{r no_show_distribution}
middle_points <- table(appData$No.show) %>% barplot(col=c(2,4))
proportions <- table(appData$No.show) %>% prop.table %>% c 
text(middle_points, y=10000, labels = Vectorize(function(v) { sprintf("%2.0f %%",v)
						})(proportions*100))
legend("topright", title="No.show", fill=c(2,4),
       legend=levels(appData$No.show))
title(main="Most patients don't miss the appointment")
```

Now, a visualization of the features and how they relate to the target.

**Gender**

```{r gender_distribution, fig.height=7}
par(mfrow=c(2,1))
tbl_gender <- table(appData$No.show, appData$Gender) 
prop_gender <- table(appData$Gender) %>% prop.table %>% c 
middle_points <- barplot(tbl_gender, xlab="Gender", ylab="count", col=c(2,4))
text(middle_points, y=10000, labels = Vectorize(function(v) { sprintf("%2.0f %%",v)
						})(prop_gender*100))
title(main="Most patients are female.")
legend("topright", title="No.show", fill=c(2,4),
       legend=levels(appData$No.show), cex=0.7)
tbl_gender %>% prop.table(2) %>% 
	barplot(xlab="Gender", ylab="Proportion", col=c(2,4))
title("Both genders are equally likely to miss the appointment")
```

**Age**

After the age of 90 years there are only a few samples, so the proportions aren't
significative.

```{r hist_ages_1, fig.show="hide"}
hist_age<-hist(appData$Age)
```
```{r hist_ages_2, fig.height=7}
par(mfrow=c(2,1))
barplot(table(appData$No.show, cut(appData$Age, hist_age$breaks,
	include.lowest=TRUE)), xlab="Age Bracket", ylab="count", col=c(2,4))
title("Histogram of Age")
legend("topright", title="No.show", fill=c(2,4), legend=levels(appData$No.show))
barplot(table(appData$No.show, cut(appData$Age, hist_age$breaks)) %>% prop.table(2),
	xlab="Age Bracket", ylab="Proportion", col=c(2,4))
title("Proportion of No.show by age")
```

**Waiting Time**

Most appointments are same-day or for the next day. Those
appointments also have better turn up. *Warning*, the histograms below have
non-uniform bin sizes.

```{r hist_wait, fig.show="hide"}
hist_wait <- hist(appData$Wait, breaks=Vectorize(function(e) {2**e})(seq(0,8))-1)
```

```{r hist_wait_2, fig.height=7}
par(mfrow=c(2,1))
tbl_wait <- table(appData$No.show, cut(appData$Wait, hist_wait$breaks,
				       include.lowest=TRUE))
barplot(tbl_wait, xlab="Wait Bracket", ylab="count", col=c(2,4))
legend("topright", title="No.show", fill=c(2,4),
       legend=levels(appData$No.show))
title("Histogram of Wait")
barplot(tbl_wait %>% prop.table(2), xlab="Wait",
			 ylab="Proportion of No.show", col=c(2,4))
title(main="Lower wait times have better turn up.")
```

**Distribution of Neighbourhoods**

```{r hist_neighbourhood, fig.height=7, cache=TRUE}
tbl_neigh <- table(appData$No.show, appData$Neighbourhood)
par(mfrow=c(2,1))
barplot(tbl_neigh, col=c(2,4),
	ylab="Count", xlab="Neighbourhood")
legend("topleft", title="No.show", fill=c(2,4),
       legend=levels(appData$No.show), cex=0.7, xpd=TRUE)
barplot(tbl_neigh %>% prop.table(2), col=c(2,4),
	ylab="Proportion", xlab="Neighbourhood")
title(main="Most locations have the same turn up ratio")
```

**Distribution of other categorical variables**

```{r hists_categorical_variables, results="hide", fig.height=20}
par(oma = c(0,0,2,0))
hs <- c(0.75,rep(1,6))
hs <- hs / sum(hs)
layout(matrix(c(1,1,seq(2,13)),nrow = 7,ncol = 2,byrow = TRUE)
       ,heights = hs)
plot(1, type = "n", axes=FALSE, xlab="", ylab="")
legend("bottom", inset=0, title="No.show",
       pch=c(15,15,21), col=c(2,4),
       legend=c("No", "Yes"),
       , horiz=TRUE)
title(main="Histogram/Composition", sub="Maybe SMS = 1 means no SMS was sent.")

mapply(FUN=function(column,varname) {
	tbl_var <- table(appData$No.show, column)
	middle_points <- barplot(tbl_var, xlab=varname, ylab="Count", col=c(2,4))
	text(middle_points, y=40000, labels = Vectorize(function(v) { sprintf("%2.0f %%",v)
						})(100*(table(column) %>%
							prop.table %>% c)))
	barplot(prop.table(tbl_var,2), xlab=varname,
				 ylab="Proportion", col=c(2,4))
},appData[,8:13], names(appData)[8:13])


```


The last row of plots suggests that when `SMS_received == 0` the patient is more
likely to show up. **Thus the `0` might mean that SMS was received**.

## Some Characteristics

**Are there patients with more than one appointment on the same day?**

Yes, but most have only one.

```{r multiple_appointments}
ordAppData <- appData[order(appData$AppointmentDay),]
ordAppData %>% group_by(PatientId, AppointmentDay) %>%
	summarize(C=n()) %>% ungroup() %>% select(C) %>% `[[`(1) %>%
	table(dnn="Appointments per day")
```

**How does showing up for the prevoius appointment predicts showing up for the
next?**

Patients that showed up for their previous appointment are more
likely to show up again.

```{r previous_appointment, cache=TRUE}
last_outcome <- ordAppData %>% group_by(PatientId, AppointmentDay) %>%
	summarize(nYes=sum(No.show == "Yes"), nNo=sum(No.show == "No")) %>% ungroup %>%
	group_by(PatientId) %>%
	mutate(pnYes=lag(nYes), pnNo=lag(nNo)) %>% ungroup

ordAppDataWithLastOutcome <- inner_join(ordAppData, last_outcome, by= c("PatientId","AppointmentDay"))

nextVsPrev <- const %$% table(ordAppDataWithLastOutcome$No.show,
			      ordAppDataWithLastOutcome$pnYes > 0, useNA="ifany")

par(mfrow=c(1,2), oma = c(0, 0, 2, 0))
middle_points <- nextVsPrev() %>%
 	barplot(xlab="Previos No.show", ylab="count",
		 names.arg=c("No", "Yes", "NA"), col=c("red","blue"))
text(middle_points, y=20000, labels =
     Vectorize(function(v) { sprintf("%2.0f %%",v) })(
 	100*(nextVsPrev() %>% margin.table(2) %>% prop.table)))
legend(x=0.5,y=60000, title="No.show", fill=c("red","blue"),
       legend=levels(appData$No.show))
nextVsPrev() %>% prop.table(2) %>%
	barplot(xlab="Previos No.show", ylab="Proportion",
		names.arg=c("No", "Yes", "NA"), col=c("red","blue"))
mtext("Next No.show vs previous No.show.", outer = TRUE, cex = 1.5)
```

## [EXTRA]Gender Composition By Age

**Why is the proportion of women so large?**

```{r age_by_gender, results="hide", fig.height=7 }
par(mfrow=c(2,1))
table(appData$Gender, cut(appData$Age, hist_age$breaks , include.lowest=TRUE)) %>%
	barplot(xlab="Age Bracket", ylab="Count", col=c(2,4))
legend("topright", title="Legend",
       pch=c(15,15), col=c(2,4),
       legend=c("Female", "Male")) 
table(appData$Gender, cut(appData$Age, hist_age$breaks,
			  include.lowest=TRUE)) %>%
	prop.table(2) %>% barplot(xlab="Age Bracket", ylab="Proportion", col=c(2,4))
title(main="Women are the majority after the age of 16.")
```

There is a sharp drop in the proportion of men after the age of 16.

**License**

Released under [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/).
Attributed to Kaggle's user [JoniHoppen](https://www.kaggle.com/joniarroba)
([Twitter](https://twitter.com/jonihoppen),[LinkedIn](https://www.linkedin.com/in/joniarroba/)).
Changes where made to the data as shown in the code.
